---
title: 反射
description: 反射基础知识
tags:
  - Java
---
# 反射
## 1. 概念

> Java语言的反射机制：在程序的运行状态中， a.判断任意一个对象所属的类；b.构造任意一个类的对象；c.判断任意一个类所具有的成员变量和方法；d.调用任意一个对象的方法；e.生成动态代理。

## 2. Class类

> 对于一个字节码文件.class，该文件本身却记录了许多信息。Java在将.class字节码文件载入时，JVM将产生一个java.lang.Class对象代表该.class字节码文件，从该Class对象中可以获得类的许多基本信息，这就是反射机制。

> 反射机制所需的类主要有java.lang包中的Class类和java.lang.reflect包中的Constructor类、Field类、Method类和Parameter类。Class类是一个比较特殊的类，它是反射机制的基础，Class类的对象表示正在运行的Java程序中的类或接口，也就是任何一个类被加载时，即将类的.class文件（字节码文件）读入内存的同时，都自动为之创建一个java.lang.Class对象。Class类没有公共构造方法，其对象是JVM在加载类时通过调用类加载器中的defineClass（）方法创建的，因此不能显式地创建一个Class对象。

> > 通俗讲：在编译后产生字节码文件时，类加载器子系统通过二进制字节流，负责从文件系统加载class文件，在执行程序（java.exe）时候，将字节码文件读入JVM中：叫做"类的加载",然后在内存中对应创建一个java.lang.Class对象'X'-->这个对象'X'会被放入字节码信息中,'X'对象就对应加载那个字节码信息,'X'对象将被作为程序访问方法区中的这个类的各种数据的外部接口。所以：我们可以通过这个对象'X'看到类的结构，对象'X'就好像是一面镜子，透过镜子看到类的各种信息。

{{%notice info%}}
在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，同一个类将不会被再次载入。被载入JVM的类都有一个唯一标识就是该类的全名，即包括包名和类名。
{{%/notice%}}

{{%notice note%}}
**动态语言**：程序运行时，允许改变程序结构或变量类型.
**静态语言**：运行时结构是不可变的
{{%/notice%}}

> 主要动态语言: Object-C、 C#、JavaScript、 PHP、 Python、 Erlang  

> 主要静态语言：java、C、C++

> > 所以Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。

## 3. 获取字节码信息的四种形式

```{.Java .extra-class #id linenums="1"}
// 1.通过getClass()方法获取
//用对象调用getClass（）方法来获得该类对应的Class对象，即“对象.getClass（）”
Number n = 0;
Class<? extends Number> c = n.getClass();

// 2.通过内置class属性：
//用类名调用该类的class属性来获得该类对应的Class对象，即“类名.class”
Number n = 0;
Class<? extends Number> c = n.Class();

// 3.方式3：--》用的最多：调用Class类提供的静态方法forName
//className -所需的类的完全限定名。forName()方法声明抛出ClassNotFoundException异常，因此调用该方法时必须捕获或抛出该异常。
Class t = Class.forName("java.lang.Thread");


// 4.方式4：利用类的加载器(了解)
//返回类的类加载器
ClassLoader loader = demo1.class.getClassLoader();
Class t = loader.loadClass("Test.demo1");

```

## 4. Class类的具体的实例

| 类：外部类，内部类 | 接口 | 注解  | 数组  | 基本数据类型 | void  |
| :-------- | :--------- | :-------- | :----------- | :----------- | :--------- |
| Thread.class       | Comparable.class | Override.class | arr1.getClass();arr2.getClass(); | int.class    | void.class |

```{.Java linenums="1"}
// 若arr1和arr2是一维数组
int[] arr1 = {1,2,3};
Class c4 = arr1.getClass();
int[] arr2 = {5,6,7};
Class c5 = arr2.getClass();
System.out.println(c4==c5);//结果：true .同一个维度，同一个元素类型,得到的字节码就是同一个
```

## 5. 获取

### 5.1 获取构造器和创建对象

```{.Java linenums="1"}
//获取字节码信息
Class<Student> cls = Student.class;

//通过字节码信息 获取构造器
//getConstructors 只能获取当前运行时类的 被public修饰的构造器
Constructor<?>[] c1 = cls.getConstructors();
for (Constructor<?> c : c1) {
    System.out.println(c);
}
System.out.println("-------------------");

//getDeclaredConstructors：获取运行时全部修饰符的构造器
Constructor<?>[] c2 = cls.getDeclaredConstructors();
for (Constructor<?> c : c2) {
    System.out.println(c );
}
System.out.println("-------------------");

// 获取指定的构造器
//得到空构造器
Constructor<Student> con1 = cls.getConstructor();
System.out.println(con1);

//得到两个参数的有参构造器：
Constructor<Student> con2 = cls.getConstructor(double.class, double.class);
System.out.println(con2);

//得到一个参数的有参构造器：并且是private修饰的
Constructor<Student> con3 = cls.getDeclaredConstructor(int.class);
System.out.println(con3);

//得到一个参数的有参构造器：并且是private修饰的
Object o1 = con1.newInstance();
System.out.println(o1);
Object o2 = con2.newInstance(166.6, 155.5);
System.out.println(o2);
```

### 5.2 获取属性并赋值

```{.Java linenums="1"}
//获取运行时字节码信息
Class<Student> cls = Student.class;
//获取属性
//getFields：获取"运行类、父类"中被public修饰的属性
Field[] fields = cls.getFields();
for (Field field : fields) {
    System.out.println(field);
}
System.out.println("____________________1");
//getDeclaredFields：获取运行时类中的所有属性（没有父类的属性）
Field[] declaredFields = cls.getDeclaredFields();
for (Field declaredField : declaredFields) {
    System.out.println(declaredField);
}
System.out.println("____________________2");

//获取指定的属性
Field sno = cls.getDeclaredField("sno");
System.out.println(sno);
Field height = cls.getDeclaredField("height");
System.out.println(height);
System.out.println("____________________3");

//属性的具体结构
//获取修饰符
int modifiers = sno.getModifiers();
System.out.println(modifiers);
System.out.println(Modifier.toString(modifiers));
System.out.println(Modifier.toString(sno.getModifiers()));
System.out.println("____________________4");
//获取属性的数据类型
Class clazz = sno.getType();
System.out.println(clazz.getName());
System.out.println("____________________5");
//获取属性的名字
String name = sno.getName();
System.out.println(name);
System.out.println("____________________6");
//给属性赋值：给属性设置值，必须要有对象
Field score = cls.getField("score");//public
Field weight = cls.getDeclaredField("weight");//protected
Field height1 = cls.getDeclaredField("height");
Student stu = cls.newInstance();
score.set(stu,100);//给stu这个对象的score属性设置具体的值
weight.set(stu,166.6);//给sut这个对象的weight属性设置具体的值
height1.set(stu,188.8);
System.out.println(stu);
```

### 5.3 获取方法并调用

```{.Java linenums="1"}
//获取字节码信息
Class<Student> cls = Student.class;
//获取方法：
//获取运行时的方法和所有父类的方法(运行时类和父类)（被public修饰的方法）
Method[] methods = cls.getMethods();
for (Method method : methods) {
    System.out.println(method);
}
System.out.println("________________1");

//获取“运行时类”中的所有方法(运行时的方法）
Method[] declaredMethods = cls.getDeclaredMethods();
for (Method declaredMethod : declaredMethods) {
    System.out.println(declaredMethod);
}
System.out.println("________________2");

//获取指定方法
Method showInfo = cls.getMethod("showInfo");
System.out.println(showInfo);
Method showInfo1 = cls.getMethod("showInfo", int.class, int.class);
System.out.println(showInfo1);
Method work = cls.getDeclaredMethod("work",int.class);
System.out.println(work);
System.out.println("________________3");

//获取方法的具体结构：
/*结构：
* @注解
* 修饰符 返回值类型 方法名(参数列表） throws XXX｛｝
* */
//获取名字
System.out.println(showInfo.getName());
//获取修饰符
int modifiers = showInfo.getModifiers();
System.out.println(Modifier.toString(modifiers));
//获取返回值
System.out.println(showInfo.getReturnType());
System.out.println("________________4");

//获取列表
Class[] parameterTypes = work.getParameterTypes();
for(Class c:parameterTypes){
    System.out.println(c);
}
System.out.println("________________5");

//获取注解
Method myMethod = cls.getMethod("myMethod");
Annotation[] annotations = myMethod.getAnnotations();
for (Annotation a : annotations) {
    System.out.println(a);
}
System.out.println("________________6");

//获取异常
Class<?>[] exceptionTypes = myMethod.getExceptionTypes();
for (Class<?> et : exceptionTypes) {
    System.out.println(et);
}
System.out.println("________________7");

//调用方法(先实例化，再调用方法）
Object stu = cls.newInstance();
myMethod.invoke(stu);//调用stu对象的myMethod方法
System.out.println("________________8");
System.out.println(showInfo.invoke(stu));//调用stu对象的showInfo方法
```

### 5.4 获取类的接口、所在包、注解

```{.Java linenums="1"}
//获取字节码信息
Class<Student> cls = Student.class;
//获取运行时类的接口
Class<?>[] interfaces = cls.getInterfaces();
for (Class<?> anInterface : interfaces) {
    System.out.println(anInterface);
}
System.out.println("___________1");

//得到父类的接口
//先获取父类的字节码信息
Class<? super Student> superclass = cls.getSuperclass();
//获取接口
Class<?>[] interfaces1 = superclass.getInterfaces();
for (Class<?> aClass : interfaces1) {
    System.out.println(aClass);
}
System.out.println("___________2");

//获取运行时类所在的包
Package aPackage = cls.getPackage();
System.out.println(aPackage.getName());
System.out.println("___________3");

//获取运行时类的注解
Annotation[] annotations = cls.getAnnotations();
for (Annotation a : annotations) {
    System.out.println(a);
}

```

## 参考文章

- [java反射机制-百度百科](https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990)
- [java-api-Class](https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Class.html)
- [马士兵教育]